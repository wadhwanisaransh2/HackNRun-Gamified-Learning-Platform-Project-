<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Marbleslides: Gravity Challenge (Upgraded)</title>
<style>
  body {
    text-align: center;
    background: linear-gradient(135deg,#e9defa 0%,#faf7fa 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #222;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-height: 100vh;
    margin: 0; padding: 20px; box-sizing: border-box;
  }
  .container {
    padding: 18px; background: white; border-radius: 13px;
    box-shadow: 0 4px 18px rgba(56,26,209,0.09);
    max-width: 100%;
  }
  h2 {
    color: #733dbe; border-bottom: 2px solid #e1e0ea; padding-bottom: 10px; margin-top: 0;
    letter-spacing: 0.05em;
  }
  canvas {
    border: 2.5px solid #733dbe;
    background: #f8f7fc;
    border-radius: 9px;
    display: block; margin: 0 auto;
  }
  .controls { margin-top: 14px; display: flex; justify-content: center; gap: 12px; align-items: center; flex-wrap: wrap; }
  input { width: 260px; padding: 10px; border: 1.5px solid #a89fc3; border-radius: 5px; font-size: 1.13em; }
  button {
    padding: 10px 16px; border: none; border-radius: 5px;
    background-color: #733dbe; color: white; font-size: 1em;
    cursor: pointer; transition: background 0.18s;
  }
  button:hover { background-color: #5935ab !important; }
  button.reset { background-color: #e43c4b; }
  button.reset:hover { background-color: #b72c36 !important;}
  button.clear { background-color: #ffe16b; color: #222;}
  button.clear:hover { background-color: #f4c233 !important;}
  p.instructions { max-width: 620px; color: #554c67; margin-bottom: 15px; font-size: 16px;}
  .status { margin-top: 10px; font-weight: bold; color: #6933be; }
</style>
</head>
<body>
<div class="container">
  <h2>‚≠ê Marbleslides: Gravity Challenge ‚≠ê</h2>
  <p class="instructions">
    Enter an equation (e.g., <b>y = -1/2x + 4</b> or <b>y = 3 { x &gt; -1 }</b>) to draw a line segment.<br>
    Use curly braces <b>{}</b> to restrict the domain. Your goal: help the purple ball collect all gold stars!
  </p>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <div class="controls">
    <input id="equationInput" placeholder="e.g., y = 1/2x + 3 { x > -1 }" onkeypress="handleKeyPress(event)">
    <button onclick="addLine()">Add Line</button>
    <button onclick="launchBall()">Launch!</button>
    <button class="clear" onclick="clearLines()">Clear Lines</button>
    <button class="reset" onclick="resetGame()">Reset</button>
  </div>
  <div class="status" id="status">Add a line and launch the ball!</div>
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const statusDiv = document.getElementById("status");

// Game constants
const SCALE = 30;
const GRAVITY = 0.15;
const FRICTION = 0.98;
const BOUNCE_DAMPING = 0.75;
const BALL_RADIUS = 8;
const STAR_RADIUS = 11;
const MIN_VELOCITY = 0.01;
const BOUNCE_THRESHOLD = 0.3;

// Game state
const origin = {x: canvas.width / 2, y: canvas.height / 2};
let ball, stars, lines = [], gameState = 'ready', animationId;

// Coordinate conversion
function toCanvas(x, y) { return [origin.x + x * SCALE, origin.y - y * SCALE]; }
function toWorld(px, py) { return [(px-origin.x)/SCALE, -(py-origin.y)/SCALE]; }

// Drawing
function drawGrid() {
  ctx.save();
  ctx.strokeStyle = "#efe7fa"; ctx.lineWidth = 1.2;
  for (let i = 0; i <= canvas.width; i += SCALE) {
    ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke();
  }
  for (let j = 0; j <= canvas.height; j += SCALE) {
    ctx.beginPath(); ctx.moveTo(0,j); ctx.lineTo(canvas.width,j); ctx.stroke();
  }
  ctx.strokeStyle = "#ccc"; ctx.lineWidth = 2.4;
  ctx.beginPath(); ctx.moveTo(origin.x,0); ctx.lineTo(origin.x,canvas.height); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,origin.y); ctx.lineTo(canvas.width,origin.y); ctx.stroke();
  ctx.fillStyle="#9a96af"; ctx.font="13px Arial"; ctx.textAlign="center";
  for (let x = -10; x <= 10; x++) {
    if (x !== 0) {
      let [px, py] = toCanvas(x, 0);
      if (px > 18 && px < canvas.width - 18) ctx.fillText(x, px, py + 18);
    }
  }
  ctx.textAlign="right";
  for (let y = -10; y <= 10; y++) {
    if (y !== 0) {
      let [px, py] = toCanvas(0, y);
      if (py > 18 && py < canvas.height - 18) ctx.fillText(y, px - 11, py + 4);
    }
  }
  ctx.restore();
}

function drawStars() {
  stars.forEach((s, idx) => {
    if (!s.collected) {
      let [px, py] = toCanvas(s.x, s.y);
      ctx.save();
      ctx.beginPath();
      for (let i = 0; i < 10; i++) {
        let angle = (i * Math.PI) / 5;
        let r = i%2===0 ? STAR_RADIUS : STAR_RADIUS/2.3;
        let x = px + Math.cos(angle)*r, y = py + Math.sin(angle)*r;
        if (i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = "gold"; ctx.strokeStyle = "#dab417"; ctx.lineWidth = 2;
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = "#2c1900"; ctx.font = "bold 15px Arial";
      ctx.fillText(idx+1, px, py+6); ctx.restore();
    }
  });
}

function drawLines() {
  lines.forEach(line => {
    ctx.save();
    ctx.strokeStyle = "#4165d7"; ctx.lineWidth = 3;
    let xmin = typeof line.xmin === "number" ? line.xmin : -canvas.width/(2*SCALE);
    let xmax = typeof line.xmax === "number" ? line.xmax : canvas.width/(2*SCALE);
    let xstep = (xmax-xmin)/100;
    ctx.beginPath();
    for (let x = xmin; x <= xmax; x += xstep) {
      let y = line.m*x + line.b;
      let [px, py] = toCanvas(x, y);
      if (x===xmin) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.fillStyle = "#3154be"; ctx.font = "13px Arial"; ctx.textAlign="left";
    let label = prettyLabel(line);
    let [lpx, lpy] = toCanvas((xmin+xmax)/2, line.m*((xmin+xmax)/2)+line.b);
    ctx.fillText(label, lpx+11, lpy-9);
    ctx.restore();
  });
}

function prettyLabel(line) {
  let mStr = (Math.abs(line.m) === 1 ? (line.m === -1 ? '-' : '') : line.m!==0 ? line.m : '');
  let bStr = (line.b > 0 ? ' + ' + line.b : (line.b < 0 ? ' - ' + Math.abs(line.b) : ''));
  let eq = '';
  if (line.m === 0) eq = `y = ${line.b}`;
  else eq = `y = ${mStr}x${bStr}`;
  if (typeof line.xmin === "number" || typeof line.xmax === "number") {
    let part = [];
    if (typeof line.xmin === "number") part.push(`x ‚â• ${line.xmin}`);
    if (typeof line.xmax === "number") part.push(`x ‚â§ ${line.xmax}`);
    eq += ` { ${part.join(', ')} }`;
  }
  return eq;
}

function drawBall() {
  let [px, py] = toCanvas(ball.x, ball.y);
  ctx.save();
  ctx.beginPath();
  ctx.arc(px+3, py+3, BALL_RADIUS, 0, 2*Math.PI);
  ctx.fillStyle = "rgba(0,0,0,0.13)"; ctx.fill();
  let grad = ctx.createRadialGradient(px-4,py-4,2,px,py,BALL_RADIUS+2);
  grad.addColorStop(0, "#dfbaff"); grad.addColorStop(1, "#733dbe");
  ctx.beginPath(); ctx.arc(px, py, BALL_RADIUS,0,2*Math.PI);
  ctx.fillStyle = grad; ctx.fill();
  ctx.beginPath(); ctx.arc(px-2, py-2, BALL_RADIUS/3,0,2*Math.PI);
  ctx.fillStyle = "rgba(255,255,255,0.7)"; ctx.fill();
  ctx.restore();
}

function drawMessage() {
  if (gameState === 'won' || gameState === 'lost') {
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.63)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.textAlign = 'center'; ctx.font = 'bold 44px Arial'; ctx.strokeStyle = '#f7f7f7'; ctx.lineWidth = 3;
    if(gameState==='won'){
      ctx.fillStyle='#11cb7f'; ctx.strokeText('üéâ YOU WIN! üéâ',canvas.width/2,canvas.height/2-10);
      ctx.fillText('üéâ YOU WIN! üéâ',canvas.width/2,canvas.height/2-10);
    } else {
      ctx.fillStyle='#e43c4b'; ctx.strokeText('üí• TRY AGAIN! üí•',canvas.width/2,canvas.height/2-10);
      ctx.fillText('üí• TRY AGAIN! üí•',canvas.width/2,canvas.height/2-10);
    }
    ctx.restore();
  }
}

function drawScene() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  drawStars();
  drawLines();
  if (ball) drawBall();
  drawMessage();
}

// --- Game Logic ---
function resetGame() {
  if (animationId) cancelAnimationFrame(animationId);
  ball = { x: 10, y: 10, vx: 0, vy: 0, r: BALL_RADIUS/SCALE, onGround: false };
  stars = [
    {x: 5.5, y: 3, collected: false},
    {x: -4, y: -1, collected: false},
    {x: 2, y: 6, collected: false}
  ];
  lines = [];
  gameState = 'ready';
  document.getElementById('equationInput').value = '';
  updateStatus("Add a line and launch the ball!");
  drawScene();
}

function clearLines() {
  if (gameState === 'ready') {
    lines = [];
    drawScene();
    updateStatus("Lines cleared. Add new lines!");
  }
}

function updateStatus(msg) { statusDiv.textContent = msg; }

function parseEquation(eq) {
  eq = eq.toLowerCase().replace(/\s+/g,"");
  if (!eq.startsWith("y=")) throw new Error("Start equation with 'y='");
  let expr = eq.substring(2);

  let domain = expr.match(/{([^}]+)}/);
  let xmin, xmax;
  if (domain) {
    expr = expr.replace(domain[0],'');
    let rules = domain[1].split(',').map(s=>s.trim());
    rules.forEach(rule => {
      if (rule.match(/x[<>]=?/)) {
        let val = parseFloat(rule.replace(/[^-.\d]/g,""));
        if(rule.includes('>')) xmin = val;
        if(rule.includes('<')) xmax = val;
      }
    });
  }

  let regex = /^((-?\d+\/\d+|-?\d*\.\d+|-?\d+|[-+])?x)?([+\-]\d+\/\d+|[+\-]\d*\.\d+|[+\-]\d+)?$/;
  let match = expr.match(regex);
  if (!match) throw new Error("Equation format invalid. Try y=mx+b");
  let m = 0, b = 0;
  if (match[1]) {
    let mstr = match[2];
    if (mstr === undefined || mstr === "" || mstr==='+') m = 1;
    else if(mstr==='-') m = -1;
    else if (mstr.includes('/')) {
      let parts = mstr.split('/'); m = parseFloat(parts[0])/parseFloat(parts[1]);
    } else m = parseFloat(mstr);
  }
  if (match[3]) {
    let bstr = match[3];
    if(bstr.includes('/')) {
      let s = bstr.startsWith('-') ? -1 : 1;
      let parts = bstr.replace('+','').replace('-','').split('/');
      b = s * parseFloat(parts[0])/parseFloat(parts[1]);
    } else b = parseFloat(bstr);
  }
  return {m,b,xmin,xmax};
}

function addLine() {
  if (gameState !== 'ready') { updateStatus("Reset first!"); return; }
  let eq = document.getElementById("equationInput").value.trim();
  if (!eq) { updateStatus("Provide an equation!"); return; }
  try {
    let line = parseEquation(eq);
    lines.push(line);
    document.getElementById('equationInput').value = '';
    updateStatus(`Line added: ${prettyLabel(line)}. Add more or launch!`);
    drawScene();
  } catch (e) {
    updateStatus("Error: "+e.message+". Try format: y=2x+3 { x > -1 }");
  }
}
function handleKeyPress(e) { if (e.key === 'Enter') addLine(); }

function launchBall() {
  if (gameState === 'ready') {
    if (lines.length === 0) { updateStatus("Add at least one line!"); return; }
    ball.x = 10; // right-most world x position
    ball.y = 10; // top-most world y position
    ball.vx = 0; ball.vy = 0; ball.onGround = false;
    stars.forEach(s=>s.collected=false);
    gameState = 'running';
    updateStatus("Ball launched! Collect all stars!");
    update();
  } else if (gameState === 'won' || gameState === 'lost') resetGame();
}

// --- Physics Engine ---
function getLineCollision(ball, line) {
  if ((typeof line.xmin === "number" && ball.x < line.xmin-0.01) ||
      (typeof line.xmax === "number" && ball.x > line.xmax+0.01)) return null;
  const a=line.m, b=-1, c=line.b; const dist = Math.abs(a*ball.x + b*ball.y + c)/Math.sqrt(a*a + b*b);
  if (dist <= ball.r) {
    const nX = a/Math.sqrt(a*a+b*b), nY = b/Math.sqrt(a*a+b*b);
    const side = Math.sign(a*ball.x + b*ball.y + c);
    return {distance: dist, normalX: nX*side, normalY: nY*side, penetration: ball.r-dist};
  }
  return null;
}

function update() {
  if (gameState!=='running') return;
  const dt = 1/60; let onSurface = false;

  ball.vy -= GRAVITY*dt;
  let newX = ball.x + ball.vx*dt, newY = ball.y + ball.vy*dt;

  for (const line of lines) {
    const testBall = { x: newX, y: newY, r: ball.r };
    const collision = getLineCollision(testBall, line);
    if (collision && collision.penetration > 0) {
      onSurface = true;
      newX -= collision.normalX*collision.penetration;
      newY -= collision.normalY*collision.penetration;
      const velDotN = ball.vx*collision.normalX + ball.vy*collision.normalY;
      if (velDotN < 0) {
        const normalSpeed = Math.abs(velDotN);
        if (normalSpeed > BOUNCE_THRESHOLD) {
          ball.vx -= velDotN*collision.normalX*(1+BOUNCE_DAMPING);
          ball.vy -= velDotN*collision.normalY*(1+BOUNCE_DAMPING);
          newX += collision.normalX*0.01;
          newY += collision.normalY*0.01;
          onSurface = false;
        } else {
          ball.vx -= velDotN*collision.normalX; ball.vy -= velDotN*collision.normalY;
          const tX = -collision.normalY, tY = collision.normalX;
          const velDotT = ball.vx*tX + ball.vy*tY;
          ball.vx = velDotT*tX*FRICTION; ball.vy = velDotT*tY*FRICTION;
          const gravityDotT = -GRAVITY*tY; ball.vx += gravityDotT*tX*dt; ball.vy += gravityDotT*tY*dt;
        }
      }
      break;
    }
  }

  ball.x = newX; ball.y = newY; ball.onGround = onSurface;

  stars.forEach(star => {
    if (!star.collected) {
      const dist = Math.sqrt((star.x-ball.x)**2+(star.y-ball.y)**2);
      if (dist < ball.r + STAR_RADIUS/SCALE) {
        star.collected=true;
        updateStatus(`Star collected! ${stars.filter(s=>s.collected).length}/${stars.length}`);
      }
    }
  });

  if (stars.every(s=>s.collected)) {
    gameState = 'won';
    updateStatus("üéâ Congratulations! All stars collected! üéâ");
  } else if (ball.y < -canvas.height/(2*SCALE)-5) {
    gameState = 'lost';
    updateStatus("üí• Ball fell! Try again with different lines!");
  }

  if (Math.abs(ball.vx)<MIN_VELOCITY && Math.abs(ball.vy)<MIN_VELOCITY && onSurface) { ball.vx=0; ball.vy=0; }
  drawScene();
  if (gameState==='running') animationId = requestAnimationFrame(update);
}

resetGame();
document.getElementById('equationInput').focus();
</script>
</body>
</html>
